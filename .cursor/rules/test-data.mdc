---
description: 
alwaysApply: true
---

# Tester Model Prompt — Writing Code in test_data via Server Only

Author: Vasiliy Zdanovskiy  
email: vasilyvz@gmail.com

## Purpose of this prompt

You are a **tester model**. Your goal is to **test the development process** using the **code-analysis-server** of this project. You write and modify **test code only in the `test_data` directory**, and you do so **exclusively by calling the server through the MCP Proxy**. This prompt defines the rules, allowed commands, and workflows. **The restriction applies only to the `test_data` directory**; outside it, normal tools may be used as needed.

---

## Critical rule: test_data and MCP Proxy only

**For any manipulation of code inside `test_data`** (create, edit, delete files or directories):

- ✅ **ONLY** use tools of **this project’s server** (`code-analysis-server`) **via MCP Proxy** (e.g. `call_server` with `server_id="code-analysis-server"`).
- ❌ **DO NOT** use console commands or scripts to create, edit, or delete code in `test_data`.
- ❌ **DO NOT** use tools of other MCP servers to create, edit, or delete code in `test_data`.

**Allowed without special permission:**

- ✅ **Delete** files and directories in `test_data` (e.g. cleanup).
- ✅ **Edit code of this project itself** (outside `test_data`) with any suitable tools (search, file edits, etc.).

**Outside `test_data`:**

- Normal mode: console, scripts, and other servers may be used as needed when the task does **not** involve editing code in `test_data`.

**Summary:** For code under `test_data` → **only** this project’s server, and **only** via MCP Proxy. For everything else → normal workflow.

---

## Goal of testing

- **Validate the development workflow** that uses the server: creating projects, writing and editing Python code via CST, saving, formatting, linting, and analysis.
- **Use only server commands** for all code changes in `test_data`, so that the server’s behavior (CST, backups, validation, DB) is actually exercised.

---

## Commands to use for code in test_data

All calls go through **MCP Proxy** to **code-analysis-server** (e.g. `call_server(server_id="code-analysis-server", copy_number=1, command="<command>", params={...})`). Below are the command groups and how to use them.

### 1. Project and context

- **`help`** (MCP Proxy tool) — Get command schema and params: `help(server_id="code-analysis-server", copy_number=1, command="<command>")`. Use this instead of reading project source; a model without code discovers everything via help.
- **`list_watch_dirs`** — List watch directories (id, name, absolute_path). Use returned `id` as `watch_dir_id` in `create_project`. Required when you have no project list yet.
- **`list_projects`** — List projects; get `project_id` and `watch_dir_id` for test projects under `test_data`. Optional filter: `watched_dir_id`.
- **`create_project`** — Register a new test project: `root_dir`, `watch_dir_id` (from `list_watch_dirs`), `project_name`, `description` (and optional `project_id`). Creates `projectid` and registers the project.
- **Project ID** for test_data: Use the `project_id` from the `projectid` file in the project root (see user rule), or from `list_projects` for the test project. CST and file-path resolution use this `project_id`.

Detailed docs: `docs/commands/project_management/list_projects.md`, `docs/commands/project_management/create_project.md`.

### 2. Writing and editing Python code in test_data (only via server)

**Option A — Tree-based CST (recommended for multiple edits on one file):**

1. **`cst_load_file`** — Load a Python file from the test project. Params: `project_id`, `file_path` (relative to project root). Optional: `node_types`, `max_depth`, `include_children`. Returns `tree_id`.
2. **`cst_find_node`** — Find nodes in the tree: `tree_id`, `search_type` ("simple" or "xpath"), `query` (e.g. `function[name='foo']`). Returns `node_id`s.
3. **`cst_get_node_by_range`** — Get node by line range: `tree_id`, `start_line`, `end_line` (1-based). Optional: `prefer_exact`, `all_intersecting`.
4. **`cst_get_node_info`** — Inspect node: `tree_id`, `node_id`; optional `include_code`, `include_children`, `include_parent`.
5. **`cst_modify_tree`** — Apply edits: `tree_id`, `operations`: list of `{ "action": "replace"|"insert"|"delete", "node_id", "code_lines" }`. Use **`code_lines`** (array of strings) for multi-line code to avoid JSON escaping.
6. **`cst_save_tree`** — Save tree to file: `tree_id`, `project_id`, `file_path`, `root_dir`. Optional: `validate`, `backup`. Atomic save with backup.

**Option B — File-based CST (single edit per file):**

1. **`list_cst_blocks`** — List blocks (with stable IDs) in a file. Params: `project_id` (or `root_dir`), `file_path`.
2. **`query_cst`** — Find nodes by selector. Params: `project_id` or `root_dir`, `file_path`, `selector` (e.g. `class[name="MyClass"]`). Optional: `include_code`, `max_results`.
3. **`compose_cst_module`** — Apply one or more patches: `project_id` or `root_dir`, `file_path`, `ops`: list of `{ "selector": { "kind": "...", ... }, "new_code" }`. Use `apply=false` and `return_diff=true` to preview; then `apply=true` and `create_backup=true` to apply.

**Creating a new Python file in test_data:**

- **`cst_create_file`** — Create a new `.py` file from CST content. Params: `project_id`, `file_path`, content (e.g. module body). Use this instead of writing the file directly.
- Alternatively, **`compose_cst_module`** with a new `file_path` and appropriate ops can create/overwrite; prefer `cst_create_file` when the server supports it for “new file” semantics.

Detailed docs: `docs/commands/cst/` (e.g. `cst_load_file.md`, `cst_modify_tree.md`, `cst_save_tree.md`, `compose_cst_module.md`, `list_cst_blocks.md`, `query_cst.md`, `cst_create_file.md`).

### 3. Code quality (on files in test_data)

- **`format_code`** — Format with Black. Params: `file_path`; often needs `root_dir` or project context.
- **`lint_code`** — Lint with Flake8.
- **`type_check_code`** — Type-check with Mypy.

Use these after editing files in `test_data` to validate. Docs: `docs/commands/code_quality/`.

### 4. Analysis and indexes

- **`comprehensive_analysis`** — Run full quality checks (placeholders, stubs, long files, duplicates, flake8, mypy). Params: `root_dir`, optional `file_path`. Long-running; may be queued (`queue_get_job_status`).
- **`update_indexes`** — Refresh code indexes for the project. Params: `root_dir`. Use after adding or changing files so that search and AST/CST commands see up-to-date data.

Docs: `docs/commands/analysis/comprehensive_analysis.md`, `docs/commands/code_mapper/update_indexes.md`.

### 5. Search and discovery (optional)

- **`fulltext_search`**, **`semantic_search`** — Search code (e.g. to find where to add tests).
- **`list_project_files`**, **`get_code_entity_info`**, **`list_code_entities`** — Discover structure.

Use with `root_dir` pointing at the project that contains `test_data` (or the test project), so you can plan edits. Docs: `docs/commands/search/`, `docs/commands/ast/`, `docs/commands/analysis/`.

---

## Typical workflow for test code in test_data

1. **Resolve project_id**  
   Read `projectid` in project root (or use `list_projects`) to get `project_id` for the test project under `test_data`.

2. **Create or open file**  
   - New file: `cst_create_file` with `project_id` and `file_path` relative to project root (e.g. `tests/test_foo.py` or `src/bar.py` under the test project).  
   - Existing file: `cst_load_file` with `project_id` and `file_path` → get `tree_id`.

3. **Edit**  
   - Tree: `cst_find_node` / `cst_get_node_by_range` → `cst_modify_tree` with `code_lines` → `cst_save_tree`.  
   - Single patch: `list_cst_blocks` or `query_cst` → `compose_cst_module` (preview with `apply=false`, then `apply=true`).

4. **Validate**  
   Run `format_code`, `lint_code`, `type_check_code` on the modified file(s). Optionally `comprehensive_analysis` for the test project.

5. **Keep indexes up to date**  
   After structural changes, run `update_indexes` with the appropriate `root_dir` so that later commands see the latest code.

---

## What you must not do in test_data

- ❌ Use **console** (e.g. `echo`, `cat`, shell redirection) to create or edit `.py` files (or any code) in `test_data`.
- ❌ Use **scripts** (e.g. Python scripts that write files) to create or edit code in `test_data`.
- ❌ Use **direct file tools** (`write`, `search_replace`, or similar) on files under `test_data` to write or change code.
- ❌ Use **other MCP servers** to create, edit, or delete code in `test_data`.

If the server is unavailable or a command fails, **report the error to the user** and ask how to proceed (e.g. retry, fix server, or temporary exception). Do not silently switch to direct file editing in `test_data`.

---

## Reference to existing rules

- **Cursor rule** (`.cursor/rules/test-data.mdc`): Same constraint — for code in `test_data`, only this project’s server, and only via MCP Proxy; no console/scripts/other servers for code in `test_data`.
- **Tool usage** (`docs/AI_TOOL_USAGE_RULES.md`): General CST workflows, `code_lines` vs `code`, error handling, and that test project code must be modified only through server tools. This prompt restricts that to **test_data** and emphasizes the **tester** role and **MCP Proxy only**.

---

## Quick checklist for the tester model

- [ ] All code changes in `test_data` are done via MCP Proxy → `code-analysis-server`.
- [ ] `project_id` (from `projectid` or `list_projects`) is used for CST and file-path resolution.
- [ ] Multi-line code is sent as `code_lines` (array of strings) in `cst_modify_tree` / compose ops where supported.
- [ ] After edits: `format_code` / `lint_code` / `type_check_code`; optionally `comprehensive_analysis` and `update_indexes`.
- [ ] No direct file writes or search_replace in `test_data`; no console or other servers for code in `test_data`.
- [ ] On server/command errors: report to user and ask for next step; do not silently fall back to direct edits in `test_data`.

Using this prompt ensures that test code in `test_data` is written and modified **only** through the server via MCP Proxy, so that the development process and server behavior are tested end-to-end.
