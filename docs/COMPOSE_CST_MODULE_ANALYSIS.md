# Сравнительный анализ команды compose_cst_module

**Author**: Vasiliy Zdanovskiy  
**Email**: vasilyvz@gmail.com  
**Date**: 2025-01-12

## Требования пользователя

Входные параметры должны быть:
1. **project_id** - идентификатор проекта
2. **file_path** - путь к файлу относительно корня проекта
3. **node_id** - идентификатор узла, к которому должна быть подсоединена ветка
   - Если пустой и файл непустой → ошибка
   - Допускается пустой для новых файлов
4. **commit_message** - текст для коммита

## Текущая реализация

### Схема параметров (get_schema)

```python
{
    "project_id": str,      # ✅ Соответствует требованию
    "file_path": str,       # ✅ Соответствует требованию
    "tree_id": str,         # ❌ НЕ соответствует требованию (должен быть node_id)
    "commit_message": str,   # ✅ Соответствует требованию (опциональный)
}
```

### Текущая логика (execute)

1. Получает `tree_id` (CST tree ID)
2. Загружает дерево через `get_tree(tree_id)`
3. Генерирует весь код из дерева: `source_code = tree.module.code`
4. **Заменяет весь файл** этим кодом
5. Валидирует, сохраняет в БД, делает git commit

### Проблемы

#### ❌ Проблема 1: Неправильный параметр
- **Текущее**: `tree_id` - идентификатор готового CST дерева
- **Требуется**: `node_id` - идентификатор узла в существующем файле

#### ❌ Проблема 2: Отсутствует логика подсоединения к узлу
- **Текущее**: Заменяет весь файл кодом из `tree_id`
- **Требуется**: Подсоединяет ветку к указанному `node_id`

#### ❌ Проблема 3: Отсутствует валидация node_id
- **Текущее**: Нет проверки на пустой `node_id` при существующем файле
- **Требуется**: 
  - Если `node_id` пустой и файл существует → ошибка
  - Если `node_id` пустой и файл новый → допустимо

#### ❌ Проблема 4: Отсутствует источник кода для вставки
- **Текущее**: Код берется из `tree.module.code` (весь файл)
- **Требуется**: Нужен источник кода для вставки в узел

## Анализ похожих команд

### cst_modify_tree
Использует `node_id` для операций:
- `replace` - замена узла
- `insert` - вставка относительно узла (parent_node_id или target_node_id)
- `delete` - удаление узла

**Логика вставки**:
```python
# Вставка относительно узла
parent_node_id: str  # Вставить в начало/конец тела родителя
target_node_id: str  # Вставить до/после целевого узла
position: "before" | "after"
code: str  # Код для вставки
```

### cst_load_file
Загружает файл и возвращает `tree_id` с метаданными узлов, включая `node_id` для каждого узла.

## Возможные решения

### Вариант 1: Использовать tree_id как источник кода + node_id для вставки
```python
{
    "project_id": str,
    "file_path": str,
    "tree_id": str,        # Источник кода (весь файл из дерева)
    "node_id": str,        # Узел для вставки (опциональный)
    "commit_message": str,
}
```

**Логика**:
- Если `node_id` пустой и файл существует → ошибка
- Если `node_id` пустой и файл новый → создать файл из `tree_id`
- Если `node_id` указан → вставить код из `tree_id` в указанный узел

### Вариант 2: Использовать code напрямую + node_id
```python
{
    "project_id": str,
    "file_path": str,
    "code": str,          # Код для вставки
    "node_id": str,       # Узел для вставки (опциональный)
    "commit_message": str,
}
```

**Логика**:
- Если `node_id` пустой и файл существует → ошибка
- Если `node_id` пустой и файл новый → создать файл с `code`
- Если `node_id` указан → вставить `code` в указанный узел

### Вариант 3: Гибридный подход
```python
{
    "project_id": str,
    "file_path": str,
    "node_id": str,       # Узел для вставки (опциональный)
    "code": str,          # Код для вставки (альтернатива tree_id)
    "tree_id": str,       # Источник кода (альтернатива code)
    "commit_message": str,
}
```

## Рекомендация

**Вариант 1** наиболее соответствует текущей архитектуре:
- Использует существующую инфраструктуру `tree_id`
- Позволяет работать с готовыми деревьями из `cst_load_file` → `cst_modify_tree` → `cst_save_tree`
- Добавляет логику вставки в узел через `node_id`

### Необходимые изменения

1. **Изменить схему**:
   - Заменить `tree_id` (required) на `tree_id` (optional) + `node_id` (optional)
   - Добавить валидацию: если `node_id` пустой и файл существует → ошибка

2. **Изменить логику execute**:
   - Если `node_id` пустой и файл существует → вернуть ошибку
   - Если `node_id` пустой и файл новый → создать файл из `tree_id` (текущая логика)
   - Если `node_id` указан → загрузить файл, найти узел, вставить код из `tree_id` в узел

3. **Использовать логику из cst_modify_tree**:
   - Использовать `modify_tree` или аналогичную логику для вставки кода в узел
   - Или использовать `tree_modifier._insert_node_relative` для вставки

## Выводы

### Критические несоответствия

1. **Параметр `tree_id` вместо `node_id`**
   - Текущая реализация использует `tree_id` (required)
   - Требуется `node_id` (optional) для указания узла вставки

2. **Отсутствует логика вставки в узел**
   - Текущая реализация заменяет весь файл
   - Требуется вставка кода в указанный узел

3. **Отсутствует валидация `node_id`**
   - Нет проверки: если `node_id` пустой и файл существует → ошибка
   - Нет проверки: если `node_id` пустой и файл новый → допустимо

4. **Неясен источник кода для вставки**
   - Если используется `tree_id`, то откуда брать код для вставки в узел?
   - Весь код из `tree_id` или только часть?

### Рекомендации

**Вариант 1: Гибридный подход (рекомендуется)**
```python
{
    "project_id": str,      # required
    "file_path": str,       # required
    "tree_id": str,         # required - источник кода
    "node_id": str,         # optional - узел для вставки
    "commit_message": str,  # optional
}
```

**Логика**:
- Если `node_id` пустой и файл существует → ошибка `NODE_ID_REQUIRED`
- Если `node_id` пустой и файл новый → создать файл из `tree_id` (текущая логика)
- Если `node_id` указан:
  1. Загрузить существующий файл через `cst_load_file`
  2. Найти узел по `node_id`
  3. Вставить код из `tree_id` в узел (использовать логику из `cst_modify_tree`)
  4. Сохранить результат

**Вариант 2: Отдельный параметр `code`**
```python
{
    "project_id": str,
    "file_path": str,
    "node_id": str,         # optional
    "code": str,            # required - код для вставки
    "commit_message": str,
}
```

**Логика**:
- Если `node_id` пустой и файл существует → ошибка
- Если `node_id` пустой и файл новый → создать файл с `code`
- Если `node_id` указан → вставить `code` в узел

## Вопросы для уточнения

1. **Откуда брать код для вставки?**
   - Из `tree_id` (весь файл из дерева)?
   - Отдельный параметр `code`?
   - Какой-то другой источник?

2. **Как именно "подсоединять ветку"?**
   - Вставить код в начало тела узла?
   - Вставить код после узла?
   - Вставить код перед узлом?
   - Заменить узел?

3. **Что делать, если `tree_id` содержит код всего файла, а нужно вставить только часть?**
   - Использовать весь код из `tree_id`?
   - Или нужен отдельный параметр с кодом для вставки?

4. **Позиция вставки**
   - Нужен ли параметр `position` ("before" | "after" | "inside")?
   - Или всегда вставлять после узла?
