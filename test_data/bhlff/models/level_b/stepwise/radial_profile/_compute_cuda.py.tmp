"""
Author: Vasiliy Zdanovskiy
email: vasilyvz@gmail.com

Radial profile computation for stepwise power law analysis.

This module implements radial profile computation methods for analyzing
the stepwise structure of phase fields, supporting both CPU and CUDA acceleration.

Theoretical Background:
    Radial profiles A(r) are computed by averaging field values over
    spherical shells centered at defects, enabling analysis of decay
    behavior and layer structure in 7D space-time.

Example:
    >>> profiler = RadialProfileComputer(use_cuda=True)
    >>> profile = profiler.compute(field, center)
"""

import numpy as np
from typing import Dict, List
import logging
import sys

# CUDA support
try:
    import cupy as cp

    CUDA_AVAILABLE = True
except ImportError:
    CUDA_AVAILABLE = False
    cp = None


class RadialProfileComputer:
    """
    Radial profile computation with CUDA acceleration.

    Physical Meaning:
        Computes radial profiles by averaging field values over spherical
        shells, providing the basis for analyzing decay behavior and
        layer structure in the phase field.

    Mathematical Foundation:
        For a field a(x), the radial profile A(r) is computed as:
        A(r) = (1/V_r) âˆ«_{|x-c|=r} |a(x)| dS
        where V_r is the volume of the spherical shell at radius r.
    """

    def __init__(self, use_cuda: bool = True, gpu_memory_ratio: float = 0.8):
        """
        Initialize radial profile computer.

        Physical Meaning:
            Sets up computer with CUDA acceleration for efficient
            computation of radial profiles in 7D phase fields.

        Args:
            use_cuda (bool): Whether to use CUDA acceleration.
            gpu_memory_ratio (float): GPU memory utilization ratio (0-1).
        """
        self.use_cuda = use_cuda and CUDA_AVAILABLE
        self.gpu_memory_ratio = gpu_memory_ratio
        self.logger = logging.getLogger(__name__)

        if self.use_cuda:
            self.xp = cp
            try:
                from ....utils.cuda_utils import get_global_backend

                self.backend = get_global_backend()
            except ImportError:
                self.backend = None
        else:
            self.xp = np
            self.backend = None

    def compute(self, field: np.ndarray, center: List[float]) -> Dict[str, np.ndarray]:
        """
        Compute radial profile of the field with automatic swap/blocking.

        Physical Meaning:
            Computes the radial profile A(r) by averaging the field
            over spherical shells centered at the defect. Automatically
            uses FieldArray for transparent swap and block processing
            when field size exceeds GPU memory.

        Args:
            field (np.ndarray): 3D or 7D field array (will be wrapped in FieldArray
                for automatic swap management if needed).
            center (List[float]): Center coordinates [x, y, z].

        Returns:
            Dict[str, np.ndarray]: Radial profile with 'r' and 'A' arrays.
        """
        import sys
        field_size_mb = field.nbytes / (1024**2) if hasattr(field, 'nbytes') else 0
        self.logger.info(
            f"[RADIAL PROFILE] compute: START - field shape={field.shape}, "
            f"size={field_size_mb:.2f}MB, center={center}, use_cuda={self.use_cuda}"
        )
        sys.stdout.flush()
        sys.stderr.flush()
        
        # Automatically wrap field in FieldArray for transparent swap management
        from bhlff.core.arrays.field_array import FieldArray

        self.logger.info(f"[RADIAL PROFILE] STEP 1: Wrapping field in FieldArray if needed...")
        sys.stdout.flush()
        sys.stderr.flush()
        if not isinstance(field, FieldArray):
            # Wrap in FieldArray - it will automatically use swap if field is large
            field_wrapped = FieldArray(array=field)
            self.logger.info(f"[RADIAL PROFILE] STEP 1 COMPLETE: Field wrapped in FieldArray")
        else:
            field_wrapped = field
            self.logger.info(f"[RADIAL PROFILE] STEP 1 COMPLETE: Field already FieldArray")
        sys.stdout.flush()
        sys.stderr.flush()

        # Extract array (may be memory-mapped if swapped)
        self.logger.info(f"[RADIAL PROFILE] STEP 2: Extracting array...")
        sys.stdout.flush()
        sys.stderr.flush()
        field_array = field_wrapped.array
        is_swapped = isinstance(field_array, np.memmap)
        self.logger.info(
            f"[RADIAL PROFILE] STEP 2 COMPLETE: Array extracted, shape={field_array.shape if field_array is not None else None}, "
            f"is_swapped={is_swapped}, type={type(field_array).__name__}"
        )
        sys.stdout.flush()
        sys.stderr.flush()

        # CRITICAL: For 7D fields, ALWAYS use window-based processing to maximize GPU utilization
        # This ensures large windows (80% GPU memory) are processed entirely on GPU
        if self.use_cuda and len(field_array.shape) == 7:
            self.logger.info(
                f"[RADIAL PROFILE] STEP 3: 7D field detected, using window-based GPU processing "
                f"(is_swapped={is_swapped})"
            )
            sys.stdout.flush()
            return self._compute_cuda_with_swap(field_array, center, field_array.shape[:3])

        if self.use_cuda:
            self.logger.info(
                f"[RADIAL PROFILE] GPU MODE: Using _compute_cuda for non-7D field. "
                f"Field shape={field_array.shape}, size={field_array.nbytes/1e9:.3f}GB"
            )
            sys.stdout.flush()
            return self._compute_cuda(field_array, center)
        else:
            self.logger.warning(
                f"[RADIAL PROFILE] CPU MODE: use_cuda=False, using _compute_cpu. "
                f"Field shape={field_array.shape}, size={field_array.nbytes/1e9:.3f}GB"
            )
            sys.stdout.flush()
            return self._compute_cpu(field_array, center)

    def compute_substrate(
        self, substrate: np.ndarray, center: List[float]
    ) -> Dict[str, np.ndarray]:
        """
        Compute radial profile of substrate transparency.

        Physical Meaning:
            Computes the radial profile T(r) by averaging the substrate
            transparency over spherical shells centered at the defect
            using vectorized operations for efficiency.

        Args:
            substrate (np.ndarray): 7D substrate field.
            center (List[float]): Center coordinates [x, y, z].

        Returns:
            Dict[str, np.ndarray]: Radial profile with 'r' and 'A' arrays.
        """
        # Always use CUDA if enabled, converting numpy arrays to cupy
        use_cuda_here = self.use_cuda
        xp = self.xp if use_cuda_here else np
        
        # Convert numpy array to cupy if CUDA is enabled
        if use_cuda_here and isinstance(substrate, np.ndarray):
            substrate = xp.asarray(substrate)

        if len(substrate.shape) == 7:
            shape = substrate.shape[:3]
        else:
            shape = substrate.shape[:3]

        x = xp.arange(shape[0], dtype=xp.float32)
        y = xp.arange(shape[1], dtype=xp.float32)
        z = xp.arange(shape[2], dtype=xp.float32)
        X, Y, Z = xp.meshgrid(x, y, z, indexing="ij")

        center_array = xp.array(center, dtype=xp.float32)
        distances = xp.sqrt(
            (X - center_array[0]) ** 2
            + (Y - center_array[1]) ** 2
            + (Z - center_array[2]) ** 2
        )

        if len(substrate.shape) == 7:
            center_phi = substrate.shape[3] // 2
            center_t = substrate.shape[6] // 2
            transparency = xp.abs(
                substrate[:, :, :, center_phi, center_phi, center_phi, center_t]
            )
        else:
            transparency = xp.abs(substrate)

        r_max = float(xp.max(distances))
        num_bins = max(20, min(100, int(r_max * 10)))
        r_bins = xp.linspace(0.0, r_max, num_bins + 1)
        r_centers = (r_bins[:-1] + r_bins[1:]) / 2.0

        distances_flat = distances.ravel()
        transparency_flat = transparency.ravel()
        bin_indices = xp.searchsorted(r_bins[1:], distances_flat, side="right")
        bin_indices = xp.clip(bin_indices, 0, num_bins - 1)

        T_radial = xp.zeros(num_bins, dtype=xp.float32)
        if hasattr(xp, "bincount"):
            bin_sums = xp.bincount(
                bin_indices, weights=transparency_flat, minlength=num_bins
            )
            bin_counts = xp.bincount(bin_indices, minlength=num_bins)
            valid_mask = bin_counts > 0
            T_radial[valid_mask] = bin_sums[valid_mask] / bin_counts[valid_mask]
        else:
            for i in range(num_bins):
                mask = bin_indices == i
                if xp.any(mask):
                    T_radial[i] = xp.mean(transparency_flat[mask])

        # Always convert back to numpy for return
        if use_cuda_here:
            T_radial = cp.asnumpy(T_radial)
            r_centers = cp.asnumpy(r_centers)

        return {"r": r_centers, "A": T_radial}


    def _compute_cuda(
        self, field: np.ndarray, center: List[float]
    ) -> Dict[str, np.ndarray]:
        """
        Compute radial profile with CUDA acceleration and automatic swap/blocking.

        Physical Meaning:
            Computes radial profile A(r) using CUDA for efficient
            processing of large 7D fields with automatic swap and block processing
            when GPU memory is insufficient.

        Args:
            field (np.ndarray): Field array (GPU or CPU).
            center (List[float]): Center coordinates [x, y, z].

        Returns:
            Dict[str, np.ndarray]: Radial profile with 'r' and 'A' arrays.
        """
        if len(field.shape) == 7:
            shape = field.shape[:3]
        else:
            shape = field.shape[:3]

        # Check if field is already swapped to disk (memory-mapped)
        is_swapped = isinstance(field, np.memmap)

        # CRITICAL: This method should only be called for non-7D fields or when
        # _compute_cuda_with_swap is not appropriate. For 7D fields, window-based
        # processing should be handled in compute() method.
        # This is a fallback for smaller fields that don't need windowing.
        field_size_bytes = field.nbytes
        field_size_gb = field_size_bytes / 1e9

        # For 7D fields, should have been handled in compute() method
        # But if we get here, use window-based processing anyway
        if len(field.shape) == 7:
            self.logger.warning(
                f"7D field in _compute_cuda (should use _compute_cuda_with_swap), "
                f"falling back to window-based processing. Shape={field.shape}, size={field_size_gb:.3f}GB"
            )
            return self._compute_cuda_with_swap(field, center, shape)
        
        # For non-7D fields, check if window-based processing is needed
        # Use same logic as FFT solver: check if field fits in single window
        use_window_processing = is_swapped
        
        if self.use_cuda and CUDA_AVAILABLE and not is_swapped:
            try:
                from ....utils.cuda_utils import calculate_optimal_window_memory
                
                # Calculate optimal window size (same as FFT solver)
                # Overhead: meshgrid (3x), distances (1x), amplitude (1x), temp arrays (2x) = ~5x
                max_window_elements, _, _ = calculate_optimal_window_memory(
                    gpu_memory_ratio=self.gpu_memory_ratio,
                    overhead_factor=5.0,
                    logger=self.logger,
                )
                
                field_elements = np.prod(field.shape)
                
                # If field doesn't fit in single window, use window-based processing
                if field_elements > max_window_elements:
                    use_window_processing = True
                    self.logger.info(
                        f"Field size {field_size_gb:.3f}GB ({field_elements/1e6:.1f}M elements) "
                        f"exceeds window size {max_window_elements/1e6:.1f}M elements, "
                        f"using window-based processing for maximum GPU utilization"
                    )
            except Exception as e:
                self.logger.warning(
                    f"Failed to check GPU memory: {e}, using window-based processing"
                )
                use_window_processing = True

        # Use window-based processing for large fields or swapped fields
        if use_window_processing:
            return self._compute_cuda_with_swap(field, center, shape)

        # Standard computation for smaller fields that fit in GPU memory
        self.logger.info(
            f"[RADIAL PROFILE] GPU MODE: Standard computation (field fits in GPU). "
            f"Field shape={field.shape}, using xp={self.xp.__name__}, "
            f"xp is cupy={self.xp is cp}"
        )
        sys.stdout.flush()
        
        x = self.xp.arange(shape[0], dtype=self.xp.float32)
        y = self.xp.arange(shape[1], dtype=self.xp.float32)
        z = self.xp.arange(shape[2], dtype=self.xp.float32)
        X, Y, Z = self.xp.meshgrid(x, y, z, indexing="ij")
        
        # DEBUG: Verify arrays are on GPU
        if self.use_cuda and CUDA_AVAILABLE:
            if not isinstance(X, cp.ndarray):
                self.logger.warning(
                    f"[RADIAL PROFILE] CPU MODE: Meshgrid not on GPU! Type: {type(X)}"
                )
                sys.stdout.flush()
            else:
                self.logger.info(
                    f"[RADIAL PROFILE] GPU MODE: Meshgrid on GPU, shape={X.shape}"
                )
                sys.stdout.flush()

        center_array = self.xp.array(center, dtype=self.xp.float32)
        distances = self.xp.sqrt(
            (X - center_array[0]) ** 2
            + (Y - center_array[1]) ** 2
            + (Z - center_array[2]) ** 2
        )

        # Synchronize GPU after distance computation
        if self.use_cuda:
            cp.cuda.Stream.null.synchronize()

        # Transfer field to GPU with memory check
        try:
            field_gpu = self.xp.asarray(field)
        except Exception as e:
            if "OutOfMemoryError" in str(type(e).__name__) or "out of memory" in str(e).lower():
                self.logger.warning(
                    f"GPU out of memory during field transfer: {e}, "
                    f"falling back to swap/block processing"
                )
                return self._compute_cuda_with_swap(field, center, shape)
            raise
        if len(field.shape) == 7:
            center_phi = field.shape[3] // 2
            center_t = field.shape[6] // 2
            amplitude = self.xp.abs(
                field_gpu[:, :, :, center_phi, center_phi, center_phi, center_t]
            )
        else:
            amplitude = self.xp.abs(field_gpu)

        # Synchronize before max operation
        if self.use_cuda:
            cp.cuda.Stream.null.synchronize()

        r_max = float(self.xp.max(distances))
        num_bins = min(100, max(20, int(r_max)))
        r_bins = self.xp.linspace(0.0, r_max, num_bins + 1)
        r_centers = (r_bins[:-1] + r_bins[1:]) / 2.0

        distances_flat = distances.ravel()
        amplitude_flat = amplitude.ravel()

        # Synchronize before searchsorted
        if self.use_cuda:
            cp.cuda.Stream.null.synchronize()

        bin_indices = self.xp.searchsorted(r_bins[1:], distances_flat, side="right")
        bin_indices = self.xp.clip(bin_indices, 0, num_bins - 1)

        A_radial = self.xp.zeros(num_bins, dtype=self.xp.float32)
        if hasattr(self.xp, "bincount"):
            # Synchronize before bincount
            if self.use_cuda:
                cp.cuda.Stream.null.synchronize()

            bin_sums = self.xp.bincount(
                bin_indices, weights=amplitude_flat, minlength=num_bins
            )
            bin_counts = self.xp.bincount(bin_indices, minlength=num_bins)

            # Synchronize after bincount
            if self.use_cuda:
                cp.cuda.Stream.null.synchronize()

            valid_mask = bin_counts > 0
            A_radial[valid_mask] = bin_sums[valid_mask] / bin_counts[valid_mask]
        else:
            for i in range(num_bins):
                mask = bin_indices == i
                if self.xp.any(mask):
                    A_radial[i] = self.xp.mean(amplitude_flat[mask])

        # Final synchronization before return
        if self.use_cuda:
            cp.cuda.Stream.null.synchronize()

        # Always convert back to numpy for return
        if self.use_cuda:
            return {
                "r": cp.asnumpy(r_centers),
                "A": cp.asnumpy(A_radial),
            }
        return {"r": r_centers, "A": A_radial}
