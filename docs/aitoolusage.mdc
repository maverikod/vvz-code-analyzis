---
alwaysApply: true
---
# AI Tool Usage Rules

**Author**: Vasiliy Zdanovskiy  
**Email**: vasilyvz@gmail.com

## Overview

This document defines rules for AI models on how to use the code analysis and refactoring tools in this project. These rules ensure efficient, safe, and correct usage of the available tools.

## 0. AI Prompt Rules (MANDATORY)

**‚ö†Ô∏è CRITICAL: These rules apply ONLY when server `code-analysis-server` is available via MCP Proxy. When server is unavailable, use fallback tools with user approval.**

### 0.1 Core Principle

**Use server tools in specified cases WHEN server is available. If server tools fail, MANDATORY to notify user and get approval before using fallback.**

**Key Points:**
- ‚úÖ Use server tools when available (reliability 9/10 vs 4/10)
- ‚úÖ Report ALL errors to user immediately
- ‚úÖ Wait for user decision before using fallback tools
- ‚ùå Never silently switch to direct file editing
- ‚ùå Never proceed without user approval on errors

### 0.2 Tool Selection Rules (MANDATORY WHEN SERVER AVAILABLE)

**IF server `code-analysis-server` is available via MCP Proxy:**

1. **MUST use server tools** for ALL Python code operations:
   - ‚úÖ Editing existing Python code ‚Üí `compose_cst_module` (MANDATORY)
   - ‚úÖ Splitting files ‚Üí `split_file_to_package` (MANDATORY)
   - ‚úÖ Code analysis ‚Üí `comprehensive_analysis`, `get_code_entity_info` (MANDATORY)
   - ‚úÖ Code quality ‚Üí `format_code`, `lint_code`, `type_check_code` (MANDATORY)

2. **NEVER use direct file editing** (`search_replace`, `write`) for existing Python code:
   - ‚ùå `search_replace` on existing `.py` files = FORBIDDEN
   - ‚ùå Direct `write` on existing `.py` files = FORBIDDEN
   - ‚úÖ Exception: Creating NEW files from scratch only

3. **Why server tools are MANDATORY (when available):**
   - **Reliability**: 9/10 vs 4/10 (automatic validation, backups, error handling)
   - **Safety**: Syntax validation, docstring checks, type hint validation
   - **Consistency**: Preserves formatting, comments, structure
   - **Recovery**: Automatic backups before changes

### 0.3 Error Handling and Fallback Rules (MANDATORY)

**CRITICAL: When server tools fail or return errors:**

1. **MUST immediately notify user** about the error:
   - Report the exact error message from server
   - Report which command failed
   - Report what operation was attempted

2. **MUST NOT automatically switch to fallback tools**:
   - ‚ùå Do NOT silently use `search_replace` if `compose_cst_module` fails
   - ‚ùå Do NOT proceed with direct file editing without user approval
   - ‚úÖ Wait for user decision

3. **User makes the decision**:
   - User decides whether to:
     - Retry the server command
     - Use fallback tools (direct file editing)
     - Cancel the operation
     - Investigate the error further

4. **Example error handling workflow**:
   ```
   Server tool fails ‚Üí Report error to user ‚Üí Wait for user decision ‚Üí 
   User approves fallback ‚Üí Use direct tools (with warning about reduced safety)
   ```

**Remember**: Model's role is to report errors and wait for user decision. User controls fallback strategy.

### 0.4 Code Editing Workflow (MANDATORY WHEN SERVER AVAILABLE)

**For existing Python files, ALWAYS follow this sequence (when server is available):**

1. **Discover** ‚Üí `list_cst_blocks` to find code structure
2. **Preview** ‚Üí `compose_cst_module` with `apply=false` to see changes
3. **Apply** ‚Üí `compose_cst_module` with `apply=true` and `create_backup=true`
4. **Validate** ‚Üí `format_code`, `lint_code`, `type_check_code`
5. **Analyze** ‚Üí `comprehensive_analysis` after logically completed steps

**If any step fails:**
- Report error to user immediately
- Wait for user decision before proceeding
- Do NOT automatically switch to direct file editing

**NEVER skip steps 1-2. NEVER use `search_replace` for Python code (when server is available).**

### 0.5 When Direct Tools Are Allowed (EXCEPTIONS ONLY)

**Direct tools (`write`, `search_replace`) ONLY for:**
- ‚úÖ Creating NEW files (file doesn't exist)
- ‚úÖ Editing non-Python files (`.md`, `.json`, `.yaml`, `.txt`)
- ‚úÖ Simple text replacements in comments/docstrings (CST still preferred)
- ‚úÖ **When server is unavailable** (with user notification)
- ‚úÖ **When server tool fails and user explicitly approves fallback**

**Direct tools FORBIDDEN for:**
- ‚ùå Modifying existing Python code (when server is available)
- ‚ùå Splitting large files (when server is available)
- ‚ùå Refactoring operations (when server is available)
- ‚ùå **Silent fallback without user approval**

### 0.6 Tool Comparison Summary

| Operation | Server Tools | Direct Tools | Winner |
|-----------|-------------|--------------|--------|
| **Reliability** | 9/10 (auto-validation, backups) | 4/10 (no validation) | **Server** |
| **Safety** | 9/10 (syntax/docstring checks) | 4/10 (no checks) | **Server** |
| **Convenience (complex)** | 8/10 (semantic operations) | 3/10 (manual work) | **Server** |
| **Convenience (simple)** | 5/10 (overhead) | 9/10 (direct) | Direct* |

*Direct tools only for simple non-code tasks or new files.

### 0.7 Quick Decision Tree

```
Is server available?
‚îú‚îÄ YES ‚Üí Is it Python code?
‚îÇ   ‚îú‚îÄ YES ‚Üí Is file existing?
‚îÇ   ‚îÇ   ‚îú‚îÄ YES ‚Üí Use compose_cst_module (MANDATORY)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ If fails ‚Üí Report error to user ‚Üí Wait for decision
‚îÇ   ‚îÇ   ‚îî‚îÄ NO ‚Üí Use write (allowed for new files)
‚îÇ   ‚îî‚îÄ NO ‚Üí Use write/search_replace (allowed for non-Python)
‚îî‚îÄ NO ‚Üí Notify user ‚Üí Get approval ‚Üí Use direct tools if approved
```

**Remember**: 
- Server tools provide 9/10 reliability vs 4/10 for direct tools
- When server is available, using direct tools for Python code is a violation
- **When server tools fail, MANDATORY to report to user and wait for decision**
- User controls fallback strategy, not the model

## 1. Tool Priority Rules

### 1.1 Primary Interface: MCP (Multi-Command Protocol)

**CRITICAL**: Always use MCP commands as the primary interface. CLI is only a fallback when MCP is unavailable.

**Priority Order**:
1. ‚úÖ **MCP Commands** (via `mcp_MCP-Proxy-2_call_server`) - PRIMARY
2. ‚ö†Ô∏è **CLI** (via `run_terminal_cmd`) - FALLBACK ONLY

**Rationale**:
- MCP provides structured, validated input/output
- MCP commands are tested and maintained
- CLI is for human users, not AI automation

**Example**:
```python
# ‚úÖ CORRECT: Use MCP
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="analyze_file",
    params={"root_dir": "/path", "file_path": "file.py"}
)

# ‚ùå WRONG: Using CLI directly
run_terminal_cmd("code_analysis analyze --file-path file.py")
```

### 1.2 Server Management

**Rule**: Server management (start/stop/restart) should be done via CLI, not MCP.

**When to restart server**:
- After any code changes in `code_analysis/` package
- After adding new MCP commands
- After modifying command implementations
- When server errors occur

**Command**:
```bash
cd /home/vasilyvz/projects/tools/code_analysis && \
source .venv/bin/activate && \
python -m code_analysis.cli.server_manager_cli --config config.json restart
```

## 2. Code Editing Priority Rules

**CRITICAL**: For editing existing code, **ALWAYS** use CST tools first. Direct file editing (`search_replace`, `write`) is **ONLY** for new files or when CST is not applicable.

### 2.1 Priority Order for Code Editing

**When editing existing code, use this priority (when server is available):**

1. ‚úÖ **CST Tools** (via `compose_cst_module` MCP command) - **PRIMARY FOR EXISTING CODE**
2. ‚ö†Ô∏è **Direct file editing** (`search_replace`, `write`) - **ONLY FOR NEW FILES OR WHEN CST FAILS AND USER APPROVES**

**IMPORTANT**: If CST tools fail, you MUST:
- Report the error to user immediately
- Wait for user decision before using fallback tools
- Do NOT automatically switch to direct file editing

**Rationale**:
- CST preserves formatting, comments, and code structure
- CST validates syntax automatically (compile check)
- CST validates docstrings and type hints
- CST normalizes imports automatically
- Direct editing can break formatting and lose comments

### 2.2 When to Use CST Tools (PRIORITY)

**ALWAYS use CST for**:
- ‚úÖ **Modifying existing code** (functions, classes, methods)
- ‚úÖ **Replacing code blocks** in existing files
- ‚úÖ **Removing code** from existing files
- ‚úÖ **Refactoring operations**
- ‚úÖ **When preserving comments/formatting is critical**
- ‚úÖ **Any change to existing `.py` files**

**CST Workflow**:
1. **Discover**: Use `list_cst_blocks` to find blocks with stable IDs
2. **Query** (optional): Use `query_cst` for complex selectors
3. **Preview**: Use `compose_cst_module` with `apply=false` and `return_diff=true`
4. **Apply**: Use `compose_cst_module` with `apply=true` and `create_backup=true`

**Example - Replacing existing method**:
```python
# ‚úÖ CORRECT: Use CST via MCP
# Step 1: List blocks to find the method
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="list_cst_blocks",
    params={"root_dir": "/path", "file_path": "file.py"}
)

# Step 2: Replace method using block_id or selector
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="compose_cst_module",
    params={
        "root_dir": "/path",
        "file_path": "file.py",
        "ops": [{
            "selector": {"kind": "method", "name": "MyClass.old_method"},
            "new_code": "def old_method(self, param: int) -> str:\n    \"\"\"Method description.\"\"\"\n    return str(param)"
        }],
        "apply": True,
        "create_backup": True,
        "return_diff": True
    }
)
```

**Example - Removing code**:
```python
# ‚úÖ CORRECT: Use CST to remove (empty new_code)
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="compose_cst_module",
    params={
        "root_dir": "/path",
        "file_path": "file.py",
        "ops": [{
            "selector": {"kind": "function", "name": "unused_function"},
            "new_code": ""  # Empty string = delete
        }],
        "apply": True
    }
)
```

### 2.3 When to Write Code Directly (EXCEPTIONS ONLY)

**Use direct code writing (`write` tool) ONLY for**:
- ‚úÖ Creating **new files/modules from scratch** (file doesn't exist)
- ‚úÖ Creating **documentation files** (.md files)
- ‚úÖ Creating **configuration files** (JSON, YAML, etc.)
- ‚úÖ Creating **test files** (when file doesn't exist)

**Use `search_replace` ONLY when**:
- ‚ö†Ô∏è CST tools failed and you need a workaround
- ‚ö†Ô∏è Editing non-Python files (markdown, config, etc.)
- ‚ö†Ô∏è Simple text replacements in comments/docstrings (though CST is still preferred)

**Example - Creating new file**:
```python
# ‚úÖ CORRECT: Direct write for new file
write(
    file_path="new_module.py",
    contents="\"\"\"New module.\"\"\"\n\nclass NewClass:\n    pass"
)
```

**Example - Editing existing file (WRONG)**:
```python
# ‚ùå WRONG: Using search_replace for existing code
search_replace(
    file_path="existing_file.py",
    old_string="def old_method(self):",
    new_string="def new_method(self, param: int) -> str:"
)
# Should use compose_cst_module instead!
```

### 2.4 Hybrid Approach

**Best Practice**: Use hybrid approach based on context:
1. **New Python files** ‚Üí Direct write (`write` tool)
2. **Existing Python files** ‚Üí **CST tools** (`compose_cst_module` via MCP)
3. **Complex refactoring** ‚Üí Specialized commands (`split_class`, `split_file_to_package`)
4. **Non-Python files** ‚Üí Direct editing (`write`, `search_replace`)

### 2.4 File Splitting Rules

**CRITICAL**: When splitting large files, **ALWAYS** use MCP proxy and splitting tools.

**Rule**: 
- ‚úÖ **MUST** use MCP commands (`split_file_to_package`, `split_class`) via `mcp_MCP-Proxy-2_call_server`
- ‚ùå **NEVER** manually split files by creating new files directly
- ‚úÖ This allows parallel testing of the code during refactoring

**Rationale**:
- MCP splitting tools preserve code structure and relationships
- Automatic testing during refactoring process
- Better code quality and consistency
- Maintains imports and dependencies correctly

**Example**:
```python
# ‚úÖ CORRECT: Use MCP splitting command
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="split_file_to_package",
    params={
        "root_dir": "/path",
        "file_path": "large_file.py",
        "config_path": "data/refactor_configs/split_config.json"
    }
)

# ‚ùå WRONG: Manual file splitting
write("new_file.py", "...")  # Don't do this for splitting!
```

## 3. Code Validation Rules

### 3.1 Automatic Validation

**Rule**: `compose_cst_module` automatically validates:
- ‚úÖ Syntax (compilation check)
- ‚úÖ Docstrings (file, class, method)
- ‚úÖ Type hints (parameters, return types)
- ‚úÖ Parameter documentation in docstrings
- ‚úÖ Attribute documentation in class docstrings

**Action**: No manual validation needed - it's automatic.

### 3.2 Manual Code Quality Checks

**When to use**:
- Before committing code
- After major refactoring
- When debugging issues

**Commands**:
```python
# Format code
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="format_code",
    params={"file_path": "file.py"}
)

# Lint code
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="lint_code",
    params={"file_path": "file.py"}
)

# Type check
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="type_check_code",
    params={"file_path": "file.py"}
)
```

## 4. File Organization Rules

### 4.1 Directory Structure

**CRITICAL**: Follow project file organization standards:

- üìÅ `docs/` - ALL documentation (.md files)
- üìÅ `scripts/` - Utility scripts (NOT pytest tests)
- üìÅ `logs/` - Server logs
- üìÅ `data/` - Database files, data files
- üìÅ `tests/` - Pytest tests only
- üìÅ `code_analysis/` - Source code only

**Rule**: When creating files, place them in the correct directory immediately.

### 4.2 File Size Limits

**Rule**: Files must not exceed 400 lines.

**Action**: If a file exceeds 400 lines:
1. **MUST** use MCP splitting tools (`split_file_to_package`, `split_class`)
2. Split into package structure via MCP commands
3. **NEVER** manually split by creating new files directly

**Why MCP splitting?**
- Allows parallel testing during refactoring
- Preserves code structure and relationships
- Maintains imports and dependencies correctly

**Check**:
```bash
wc -l code_analysis/**/*.py
```

**Split via MCP**:
```python
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="split_file_to_package",
    params={
        "root_dir": "/path",
        "file_path": "large_file.py",
        "config_path": "data/refactor_configs/split_config.json"
    }
)
```

## 5. Code Analysis Workflow

### 5.1 Before Making Changes

**Always**:
1. ‚úÖ Check if functionality already exists using `code_mapper` indexes
2. ‚úÖ Search existing code using `fulltext_search` or `semantic_search`
3. ‚úÖ Check file size with `wc -l`
4. ‚úÖ Review related code using `get_code_entity_info`

**Commands**:
```python
# Search for existing functionality
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="fulltext_search",
    params={"root_dir": "/path", "query": "functionality_name"}
)

# Get entity information
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="get_code_entity_info",
    params={"root_dir": "/path", "entity_type": "class", "entity_name": "ClassName"}
)
```

### 5.2 After Making Changes

**Always**:
1. ‚úÖ Run `black` (automatic via `format_code`)
2. ‚úÖ Run `flake8` (automatic via `lint_code`)
3. ‚úÖ Run `mypy` (automatic via `type_check_code`)
4. ‚úÖ **Run comprehensive analysis** (after each logically completed step)
5. ‚úÖ Update `code_mapper` indexes
6. ‚úÖ Restart server if code changed

**Commands**:
```python
# Update indexes
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="update_indexes",
    params={"root_dir": "/path"}
)
```

### 5.3 Comprehensive Code Quality Check

**CRITICAL**: After each logically completed step, run comprehensive analysis to check code quality.

**Rule**: 
- ‚úÖ **MUST** run `comprehensive_analysis` after each logically completed step
- ‚úÖ This ensures all code quality issues are detected early
- ‚úÖ Helps maintain code quality throughout development

**When to run**:
- After implementing a new feature
- After refactoring code
- After fixing bugs
- Before committing changes
- After merging code from different branches

**Command**:
```python
# Comprehensive analysis for specific file
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="comprehensive_analysis",
    params={
        "root_dir": "/home/vasilyvz/projects/tools/code_analysis",
        "file_path": "code_analysis/core/new_module.py",  # Optional: specific file
        "check_placeholders": True,      # Check for TODO, FIXME, etc.
        "check_stubs": True,             # Check for pass, ellipsis, NotImplementedError
        "check_empty_methods": True,     # Check for empty methods (excluding abstract)
        "check_imports": True,           # Check imports not at top
        "check_long_files": True,        # Check files > 400 lines
        "check_duplicates": True,        # Check for code duplicates
        "check_flake8": True,            # Run flake8 linting
        "check_mypy": True,              # Run mypy type checking
        "duplicate_min_lines": 5,        # Minimum lines for duplicates
        "duplicate_min_similarity": 0.8, # Minimum similarity for duplicates
        "max_lines": 400                 # Maximum lines threshold
    },
    use_queue=True  # This is a long-running command
)

# Comprehensive analysis for entire project
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="comprehensive_analysis",
    params={
        "root_dir": "/home/vasilyvz/projects/tools/code_analysis",
        # file_path omitted = analyze all files in project
        "check_placeholders": True,
        "check_stubs": True,
        "check_empty_methods": True,
        "check_imports": True,
        "check_long_files": True,
        "check_duplicates": True,
        "check_flake8": True,
        "check_mypy": True
    },
    use_queue=True
)

# Check job status and get results
result = mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="queue_get_job_status",
    params={"job_id": "comprehensive_analysis_..."}  # Job ID from previous call
)

# Results structure:
# {
#   "placeholders": [...],      # TODO, FIXME, etc.
#   "stubs": [...],            # Functions with pass, ellipsis, etc.
#   "empty_methods": [...],     # Methods without body (excluding abstract)
#   "imports_not_at_top": [...], # Imports after non-import statements
#   "long_files": [...],        # Files exceeding line limit
#   "duplicates": [...],         # Code duplicates
#   "flake8_errors": [...],      # Flake8 linting errors
#   "mypy_errors": [...],       # Mypy type checking errors
#   "summary": {
#     "total_placeholders": int,
#     "total_stubs": int,
#     "total_empty_methods": int,
#     "total_imports_not_at_top": int,
#     "total_long_files": int,
#     "total_duplicate_groups": int,
#     "total_duplicate_occurrences": int,
#     "total_flake8_errors": int,
#     "files_with_flake8_errors": int,
#     "total_mypy_errors": int,
#     "files_with_mypy_errors": int
#   }
# }
```

**Action after comprehensive analysis**:
1. ‚úÖ Review all detected issues
2. ‚úÖ Fix critical issues immediately (errors, duplicates, long files)
3. ‚úÖ Address warnings and suggestions
4. ‚úÖ Re-run analysis to verify fixes
5. ‚úÖ Commit only after all issues are resolved

## 6. Available MCP Commands

### 6.1 Analysis Commands

- `analyze_project` - Analyze entire project
- `analyze_file` - Analyze single file
- `get_code_entity_info` - Get detailed entity information
- `list_code_entities` - List entities by type

### 6.2 Search Commands

- `fulltext_search` - Full-text search in code
- `semantic_search` - Semantic search using embeddings
- `find_classes` - Find classes by pattern
- `list_class_methods` - List methods of a class
- `find_usages` - Find usages of entity

### 6.3 AST Commands

- `get_ast` - Get AST for file
- `search_ast_nodes` - Search AST nodes
- `ast_statistics` - Get AST statistics
- `list_project_files` - List project files

### 6.4 Refactoring Commands

- `split_class` - Split class into multiple classes
- `extract_superclass` - Extract base class
- `split_file_to_package` - Split file into package
- `compose_cst_module` - Apply CST-based patches

### 6.5 CST Commands

- `list_cst_blocks` - List logical blocks with stable IDs
- `query_cst` - Query using CSTQuery selectors
- `compose_cst_module` - Apply CST patches

### 6.6 Code Quality Commands

- `format_code` - Format with black
- `lint_code` - Lint with flake8
- `type_check_code` - Type check with mypy

### 6.7 Utility Commands

- `update_indexes` - Update code_mapper indexes
- `get_imports` - Get imports
- `find_dependencies` - Find dependencies
- `get_class_hierarchy` - Get class hierarchy

### 6.8 Comprehensive Analysis Commands

- `comprehensive_analysis` - Comprehensive code quality analysis combining:
  - Placeholders (TODO, FIXME, etc.)
  - Stubs (pass, ellipsis, NotImplementedError)
  - Empty methods (excluding abstract)
  - Imports not at top of file
  - Long files (>400 lines)
  - Code duplicates (structural and semantic)
  - Flake8 linting errors
  - Mypy type checking errors

## 7. Error Handling Rules

### 7.1 When Errors Occur

**Rule**: Always investigate and fix errors immediately.

**Process**:
1. ‚úÖ Read error message carefully
2. ‚úÖ Check server logs (`logs/mcp_server.log`)
3. ‚úÖ Verify file syntax
4. ‚úÖ Check imports and dependencies
5. ‚úÖ Restart server if needed
6. ‚úÖ Fix the issue before continuing

**Never**:
- ‚ùå Ignore errors
- ‚ùå Skip validation
- ‚ùå Continue with broken code

### 7.2 Common Error Patterns

**Docstring Validation Errors**:
- Missing file-level docstring
- Missing class docstring
- Missing method docstring
- Missing parameter descriptions
- Missing attribute descriptions
- Missing type hints

**Solution**: Add required docstrings and type hints.

**Compilation Errors**:
- Syntax errors in new code
- Import errors
- Type errors

**Solution**: Fix syntax/imports, run type checker.

## 8. Code Writing Standards

### 8.1 Docstring Requirements

**CRITICAL**: All code must have proper docstrings:

1. **File-level docstring** (required):
   ```python
   """
   Module description.
   
   Author: Vasiliy Zdanovskiy
   email: vasilyvz@gmail.com
   """
   ```

2. **Class docstring** (required):
   ```python
   class MyClass:
       """
       Class description.
       
       Attributes:
           attr1: Description of attr1
           attr2: Description of attr2
       """
   ```

3. **Method docstring** (required):
   ```python
   def method(self, param1: int, param2: str) -> bool:
       """
       Method description.
       
       Args:
           param1: Description of param1
           param2: Description of param2
       
       Returns:
           Description of return value
       """
   ```

### 8.2 Type Hints

**Rule**: All functions/methods must have:
- ‚úÖ Type hints for all parameters (except `self`/`cls`)
- ‚úÖ Return type hint (except `__init__`)

**Example**:
```python
# ‚úÖ CORRECT
def process_data(data: dict[str, Any], count: int) -> list[str]:
    ...

# ‚ùå WRONG
def process_data(data, count):
    ...
```

### 8.3 Import Organization

**Rule**: Imports are automatically normalized by `compose_cst_module`.

**Manual organization**:
1. Standard library imports
2. Third-party imports
3. Local imports

## 9. Workflow Examples

### 9.1 Creating New Module

```python
# 1. Create module with compose_cst_module
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="compose_cst_module",
    params={
        "root_dir": "/path",
        "file_path": "new_module.py",
        "ops": [{
            "selector": {"kind": "module"},
            "file_docstring": "New module description",
            "new_code": "class NewClass:\n    \"\"\"Class description.\"\"\"\n    pass"
        }],
        "apply": True
    }
)

# 2. Validate
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="format_code",
    params={"file_path": "new_module.py"}
)

# 3. Update indexes
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="update_indexes",
    params={"root_dir": "/path"}
)
```

### 9.2 Modifying Existing Code (CRITICAL: Use CST)

**ALWAYS use CST tools for existing code. Never use `search_replace` or direct editing.**

```python
# Step 1: Discover blocks to understand structure
blocks_result = mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="list_cst_blocks",
    params={"root_dir": "/path", "file_path": "file.py"}
)
# Returns: {"blocks": [{"id": "function:my_func:10-20", "kind": "function", ...}]}

# Step 2 (optional): Query for specific nodes if needed
query_result = mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="query_cst",
    params={
        "root_dir": "/path",
        "file_path": "file.py",
        "selector": "function[name='my_func'] smallstmt[type='Return']"
    }
)
# Returns: {"matches": [{"node_id": "...", "kind": "smallstmt", ...}]}

# Step 3: Preview changes (recommended)
preview_result = mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="compose_cst_module",
    params={
        "root_dir": "/path",
        "file_path": "file.py",
        "ops": [{
            "selector": {"kind": "block_id", "block_id": "function:my_func:10-20"},
            # OR: {"kind": "method", "name": "MyClass.method"},
            # OR: {"kind": "cst_query", "query": "function[name='my_func']"},
            "new_code": "def my_func(param: int) -> str:\n    \"\"\"Updated function.\"\"\"\n    return str(param)"
        }],
        "apply": False,  # Preview only
        "return_diff": True,
        "return_source": False
    }
)
# Check preview_result["data"]["diff"] before applying

# Step 4: Apply changes
result = mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="compose_cst_module",
    params={
        "root_dir": "/path",
        "file_path": "file.py",
        "ops": [{
            "selector": {"kind": "block_id", "block_id": "function:my_func:10-20"},
            "new_code": "def my_func(param: int) -> str:\n    \"\"\"Updated function.\"\"\"\n    return str(param)"
        }],
        "apply": True,
        "create_backup": True,
        "return_diff": True
    }
)

# Step 5: Validate and restart
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="format_code",
    params={"file_path": "file.py"}
)

# Step 6: Run comprehensive analysis (after logically completed step)
comprehensive_result = mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="comprehensive_analysis",
    params={
        "root_dir": "/path",
        "file_path": "file.py",
        "check_placeholders": True,
        "check_stubs": True,
        "check_empty_methods": True,
        "check_imports": True,
        "check_long_files": True,
        "check_duplicates": True,
        "check_flake8": True,
        "check_mypy": True
    },
    use_queue=True
)

# Get results when job completes
if comprehensive_result.get("result", {}).get("queued"):
    job_id = comprehensive_result["result"]["job_id"]
    # Poll for results
    import time
    while True:
        status = mcp_MCP-Proxy-2_call_server(
            server_id="code-analysis-server",
            command="queue_get_job_status",
            params={"job_id": job_id}
        )
        if status["result"]["data"]["status"] == "completed":
            analysis_results = status["result"]["data"]["result"]["result"]["data"]
            # Review and fix issues found in analysis_results
            break
        elif status["result"]["data"]["status"] == "failed":
            # Handle error
            break
        time.sleep(1)

# Restart server if code changed
run_terminal_cmd("cd /path && source .venv/bin/activate && python -m code_analysis.cli.server_manager_cli --config config.json restart")
```

**Selector Types for `compose_cst_module`**:
- `{"kind": "block_id", "block_id": "..."}` - Use stable ID from `list_cst_blocks`
- `{"kind": "function", "name": "func_name"}` - Find by function name
- `{"kind": "class", "name": "ClassName"}` - Find by class name
- `{"kind": "method", "name": "ClassName.method"}` - Find by qualified method name
- `{"kind": "node_id", "node_id": "..."}` - Use node ID from `query_cst`
- `{"kind": "cst_query", "query": "..."}` - Use CSTQuery selector string
- `{"kind": "range", "start_line": 10, "end_line": 20}` - Use line range

### 9.3 Refactoring Large File

**CRITICAL**: Always use MCP splitting tools, never split manually!

```python
# 1. Check file size
run_terminal_cmd("wc -l code_analysis/core/large_file.py")

# 2. Analyze structure
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="list_cst_blocks",
    params={"root_dir": "/path", "file_path": "large_file.py"}
)

# 3. Split file using MCP command (REQUIRED - allows parallel testing)
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="split_file_to_package",
    params={
        "root_dir": "/path",
        "file_path": "large_file.py",
        "config_path": "data/refactor_configs/split_config.json"
    }
)

# 4. Update indexes
mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="update_indexes",
    params={"root_dir": "/path"}
)
```

**Why MCP splitting?**
- ‚úÖ Preserves code structure and relationships
- ‚úÖ Automatic testing during refactoring
- ‚úÖ Maintains imports and dependencies
- ‚úÖ Better code quality and consistency
- ‚ùå Manual splitting breaks these guarantees

## 10. Best Practices Summary

### 10.1 Always Do

- ‚úÖ Use MCP commands as primary interface
- ‚úÖ **Use CST tools (`compose_cst_module`) for ALL existing code modifications**
- ‚úÖ **Use `list_cst_blocks` and `query_cst` to discover code structure before editing**
- ‚úÖ Preview changes with `apply=false` and `return_diff=true` before applying
- ‚úÖ **Run `comprehensive_analysis` after each logically completed step**
- ‚úÖ Validate code before committing
- ‚úÖ Follow file organization standards
- ‚úÖ Keep files under 400 lines
- ‚úÖ Add proper docstrings and type hints
- ‚úÖ Restart server after code changes
- ‚úÖ Update indexes after changes
- ‚úÖ Use direct write (`write` tool) ONLY for new files

### 10.2 Never Do

- ‚ùå **Use `search_replace` or direct editing for existing Python code** (use CST tools!)
- ‚ùå **Edit existing code without first using `list_cst_blocks` or `query_cst`**
- ‚ùå Use CLI when MCP is available
- ‚ùå Skip validation
- ‚ùå Ignore errors
- ‚ùå Create files in wrong directories
- ‚ùå Exceed 400 lines per file
- ‚ùå Skip docstrings
- ‚ùå Skip type hints
- ‚ùå Continue with broken code
- ‚ùå **Manually split large files** (always use MCP splitting tools)

## 11. Quick Reference

### 11.1 Command Priority

1. **MCP** ‚Üí `mcp_MCP-Proxy-2_call_server`
2. **CLI** ‚Üí `run_terminal_cmd` (fallback only)

### 11.2 Code Editing Priority

1. **Existing Python code** ‚Üí **CST tools** (`compose_cst_module` via MCP) - **REQUIRED**
2. **New Python files** ‚Üí Direct write (`write` tool)
3. **Non-Python files** ‚Üí Direct editing (`write`, `search_replace`)

**CST Workflow**:
1. `list_cst_blocks` ‚Üí discover structure
2. `query_cst` (optional) ‚Üí find specific nodes
3. `compose_cst_module` with `apply=false` ‚Üí preview
4. `compose_cst_module` with `apply=true` ‚Üí apply

### 11.3 Validation

- **Automatic** ‚Üí `compose_cst_module` validates automatically
- **Manual** ‚Üí `format_code`, `lint_code`, `type_check_code`

### 11.4 After Changes

1. Format code
2. Lint code
3. Type check
4. **Run comprehensive analysis** (after each logically completed step)
5. Update indexes
6. Restart server

---

**Remember**: This project is a tool for AI. The goal is not just writing code, but creating a tool that works primarily through MCP. CLI is just a fallback option.

