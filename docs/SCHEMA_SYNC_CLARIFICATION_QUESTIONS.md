# Schema Synchronization - Clarification Questions

**Author**: Vasiliy Zdanovskiy  
**email**: vasilyvz@gmail.com  
**Date**: 2026-01-10

## Questions Before Implementation

### Q1: BackupManager root_dir для БД

**Решение**: 
- Путь для бекапов в конфиге: `code_analysis.storage.backup_dir`
- Если не указан - по умолчанию `{project_root}/backups`
- Проектный корень определяется из пути к БД: если БД в `data/`, то корень = `db_path.parent.parent`
- Если БД не в `data/`, используется `config_dir` как корень

**Реализация**: 
- Добавить `backup_dir` в `StoragePaths`
- Использовать `backup_dir` для хранения бекапов БД
- Метод `create_database_backup()` принимает `backup_dir` как параметр

---

### Q2: Бекап при первой синхронизации

**Решение**: 
- Если база пустая - бекап не нужен
- Бекап создается только если БД содержит данные (есть таблицы с записями)
- Проверка выполняется через `_is_database_empty()` метод

**Реализация**:
- Метод `_is_database_empty()` проверяет наличие таблиц и данных
- Если БД пустая, `create_database_backup()` возвращает `None` без создания бекапа

---

### Q3: Обработка ошибок синхронизации

**Решение**: 
- Блокировать подключение с логированием
- При ошибке синхронизации raise exception, не подключаться
- Логировать детальную информацию об ошибке

**Реализация**:
- `sync_schema()` при ошибке выбрасывает исключение
- SQLiteDriver.connect() не завершается успешно если sync_schema() провалился
- Детальное логирование всех шагов синхронизации

---

### Q4: Одновременные подключения

**Решение**: 
- Перед синхронизацией база блокируется
- Использовать файловый lock или транзакцию для блокировки
- DBWorker обрабатывает запросы последовательно, но нужна дополнительная блокировка

**Реализация**:
- Использовать файловый lock на время синхронизации
- Lock файл: `{db_path}.schema_sync.lock`
- Первый процесс получает lock, остальные ждут
- После синхронизации lock освобождается

---

### Q5: Версия схемы для существующих БД

**Решение**: 
- База еще нет, проект в разработке, можно с нуля
- Для существующих БД без `db_settings`: версия "0.0.0"
- "0.0.0" означает "старая схема, нужна синхронизация"

**Реализация**:
- Если таблицы `db_settings` нет - версия считается "0.0.0"
- При синхронизации создается таблица и устанавливается текущая версия

---

### Q6: Миграция данных при пересоздании таблицы

**Решение**: 
- При синхронизации это проблема кода если не учтено
- Прервать процесс и откатиться
- Проверка должна делаться до изменения таблиц
- Валидация данных перед пересозданием таблицы

**Реализация**:
- Перед пересозданием таблицы проверять совместимость данных
- Если данные несовместимы - откатить изменения, выбросить исключение
- Все проверки выполняются до начала изменений схемы
- Если проверка провалилась - синхронизация не начинается

---

### Q7: Создание db_settings

**Решение**: 
- Для обоих - создавать в `_create_schema()` и в `sync_schema()`
- `_create_schema()` создает для новых БД
- `sync_schema()` проверяет и создает если отсутствует

**Реализация**:
- `_create_schema()` всегда создает `db_settings` если не существует
- `sync_schema()` проверяет наличие таблицы, создает если отсутствует
- Оба метода устанавливают начальную версию "0.0.0" если версия не установлена

---

### Q8: Начальная версия SCHEMA_VERSION

**Решение**: 
- Начальная версия "0.0.0"
- После первой успешной синхронизации устанавливается версия из кода

**Реализация**:
- Константа `SCHEMA_VERSION = "0.0.0"` в `base.py`
- При синхронизации версия обновляется до текущей версии кода
- Старые БД без версии считаются "0.0.0"

---

## Summary

Ожидаемые ответы:
1. **Q1**: Вариант C - бекапы БД рядом с БД
2. **Q2**: Вариант B - бекап только если БД не пустая
3. **Q3**: Вариант D - зависит от типа ошибки
4. **Q4**: Вариант D - DBWorker обрабатывает последовательно
5. **Q5**: Вариант A - "0.0.0" для старых БД
6. **Q6**: Вариант B - конвертировать если возможно
7. **Q7**: Вариант C - создавать в обоих местах
8. **Q8**: Вариант A - "1.0.0"
