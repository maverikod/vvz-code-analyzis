# Анализ AST узлов и поиск логических дублей

**Author**: Vasiliy Zdanovskiy  
**Email**: vasilyvz@gmail.com  
**Date**: 2025-12-30

## Обзор

AST (Abstract Syntax Tree) предоставляет мощные возможности для анализа кода и поиска дубликатов на **семантическом уровне**, а не просто текстовом. Это позволяет находить логически похожий код даже при различиях в именах переменных, форматировании или комментариях.

## Текущие возможности

### 1. Команды для работы с AST

#### `get_ast` - Получение AST для файла
```python
# Получить полный AST JSON для файла
result = mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="get_ast",
    params={
        "root_dir": "/path",
        "file_path": "file.py",
        "include_json": True  # Получить полный AST JSON
    }
)
```

**Что можно делать**:
- Получить структуру AST для анализа
- Сравнить AST разных файлов
- Извлечь структуру методов/классов

#### `search_ast_nodes` - Поиск узлов по типу
```python
# Найти все классы в проекте
result = mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="search_ast_nodes",
    params={
        "root_dir": "/path",
        "node_type": "ClassDef",  # или "FunctionDef", "method"
        "file_path": "optional/path",  # опционально
        "limit": 100
    }
)
```

**Что можно делать**:
- Найти все классы/функции/методы
- Сравнить структуру похожих узлов
- Анализировать паттерны в коде

#### `ast_statistics` - Статистика AST
```python
# Получить статистику по AST
result = mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="ast_statistics",
    params={
        "root_dir": "/path",
        "file_path": "optional/file.py"  # опционально
    }
)
```

### 2. Хранение AST в БД

AST хранится в таблице `ast_trees`:
- `ast_json` - полный AST в формате JSON
- `ast_hash` - SHA256 хеш AST для быстрого сравнения
- `file_id` - связь с файлом
- `file_mtime` - время модификации файла

**Важно**: `ast_hash` позволяет быстро находить **идентичные** AST деревья.

## Поиск дубликатов кода через AST

### Метод 1: Поиск идентичных AST (точные дубликаты)

**Идея**: Использовать `ast_hash` для поиска файлов с идентичной структурой AST.

**Реализация** (нужно добавить команду):
```python
# Найти файлы с одинаковым ast_hash
SELECT f1.path as file1, f2.path as file2, at1.ast_hash
FROM ast_trees at1
JOIN ast_trees at2 ON at1.ast_hash = at2.ast_hash AND at1.file_id != at2.file_id
JOIN files f1 ON at1.file_id = f1.id
JOIN files f2 ON at2.file_id = f2.id
WHERE f1.project_id = ?
```

**Ограничения**:
- Находит только **точные** дубликаты (идентичная структура)
- Не учитывает различия в именах переменных
- Не находит логически похожий код с разной структурой

### Метод 2: Сравнение структуры методов/классов

**Идея**: Извлечь структуру методов (аргументы, тело) и сравнить.

**Текущие возможности**:
```python
# 1. Получить AST для двух файлов
ast1 = get_ast("file1.py")
ast2 = get_ast("file2.py")

# 2. Извлечь методы из AST JSON
# 3. Сравнить структуру методов (нормализовать имена переменных)
# 4. Найти похожие методы
```

**Что можно сравнивать**:
- Количество аргументов
- Структура тела метода (if/for/while/return)
- Вызовы функций
- Типы операций

### Метод 3: Семантический поиск (уже доступен)

**Команда**: `semantic_search`

```python
# Найти семантически похожий код
result = mcp_MCP-Proxy-2_call_server(
    server_id="code-analysis-server",
    command="semantic_search",
    params={
        "root_dir": "/path",
        "query": "функция для обработки массива с проверкой памяти",
        "k": 10,
        "min_score": 0.7
    }
)
```

**Преимущества**:
- Находит логически похожий код
- Работает на уровне смысла, а не синтаксиса
- Учитывает контекст

**Ограничения**:
- Требует векторные embeddings
- Может давать ложные срабатывания
- Не показывает точную степень похожести структуры

### Метод 4: Анализ паттернов через `search_ast_nodes`

**Идея**: Найти все методы с похожей структурой.

**Пример**:
```python
# 1. Найти все методы с определенным паттерном
methods = search_ast_nodes(
    node_type="FunctionDef",
    file_path="test_data/bhlff"
)

# 2. Для каждого метода получить AST
# 3. Извлечь структуру (нормализовать)
# 4. Группировать по похожести
```

## Предлагаемая новая команда: `find_code_duplicates`

### Схема команды

```python
{
    "name": "find_code_duplicates",
    "params": {
        "root_dir": "string (required)",
        "min_similarity": "float (0.0-1.0, default: 0.8)",
        "entity_type": "string (optional: 'method', 'function', 'class')",
        "file_path": "string (optional)",
        "normalize_names": "boolean (default: true)",
        "compare_structure_only": "boolean (default: false)"
    }
}
```

### Алгоритм поиска дубликатов

1. **Извлечение AST узлов**:
   - Получить все методы/функции/классы через `search_ast_nodes`
   - Для каждого получить полный AST через `get_ast`

2. **Нормализация AST**:
   - Заменить имена переменных на `_VAR_`, `_VAR2_`, etc.
   - Заменить строковые литералы на `_STR_`
   - Заменить числовые литералы на `_NUM_`
   - Сохранить структуру (if/for/while/call)

3. **Сравнение**:
   - Вычислить хеш нормализованного AST
   - Группировать по хешам (точные дубликаты)
   - Для похожих структур использовать tree edit distance

4. **Результат**:
   ```json
   {
       "duplicates": [
           {
               "type": "method",
               "similarity": 1.0,
               "entities": [
                   {
                       "file_path": "file1.py",
                       "class_name": "ClassA",
                       "method_name": "method1",
                       "line": 10
                   },
                   {
                       "file_path": "file2.py",
                       "class_name": "ClassB",
                       "method_name": "method2",
                       "line": 25
                   }
               ],
               "normalized_ast_hash": "abc123..."
           }
       ],
       "total_groups": 5,
       "total_duplicates": 12
   }
   ```

### Реализация через существующие команды (временное решение)

Пока команда не реализована, можно использовать комбинацию существующих:

```python
# Шаг 1: Найти все методы
methods = search_ast_nodes(
    node_type="FunctionDef",
    file_path="test_data/bhlff"
)

# Шаг 2: Для каждого метода получить AST
for method in methods:
    ast_data = get_ast(
        file_path=method["file_path"],
        include_json=True
    )
    # Извлечь метод из AST JSON
    # Нормализовать
    # Сравнить с другими

# Шаг 3: Группировать по похожести
```

## Примеры использования

### Пример 1: Поиск дубликатов методов инициализации

```python
# Найти все методы __init__ с похожей структурой
init_methods = search_ast_nodes(
    node_type="FunctionDef",
    # Фильтр по имени через SQL или post-processing
)

# Сравнить структуру каждого __init__
# Найти методы с одинаковой структурой присваиваний
```

### Пример 2: Поиск похожих обработчиков ошибок

```python
# Найти все try/except блоки
# Сравнить структуру обработки ошибок
# Найти дубликаты паттернов обработки
```

### Пример 3: Поиск дубликатов через семантический поиск

```python
# Найти семантически похожий код
results = semantic_search(
    query="обработка ошибок памяти GPU с проверкой доступной памяти",
    k=20,
    min_score=0.8
)

# Результаты покажут похожие фрагменты кода
```

## Преимущества AST-подхода для поиска дубликатов

### 1. Семантическое понимание
- Понимает **структуру** кода, а не текст
- Игнорирует различия в именах переменных
- Учитывает контекст (класс, метод)

### 2. Точность
- Находит логические дубликаты, а не случайные совпадения
- Может нормализовать код для сравнения
- Учитывает структуру (if/for/while/call)

### 3. Масштабируемость
- AST хранится в БД, не нужно перепарсивать
- Можно использовать `ast_hash` для быстрого поиска
- Можно индексировать структуру для быстрого поиска

## Ограничения текущего подхода

1. **Нет готовой команды**: Нужно комбинировать несколько команд
2. **Нет нормализации**: Нет автоматической нормализации имен переменных
3. **Нет tree edit distance**: Нет алгоритма для поиска похожих (не идентичных) структур
4. **Нет группировки**: Нет автоматической группировки дубликатов

## Рекомендации

### Краткосрочные (использовать существующие команды)

1. **Использовать `semantic_search`** для поиска логически похожего кода
2. **Использовать `get_ast` + `search_ast_nodes`** для ручного анализа
3. **Использовать `ast_hash`** для поиска точных дубликатов через SQL

### Долгосрочные (реализовать новую команду)

1. **Создать команду `find_code_duplicates`**:
   - Нормализация AST (замена имен переменных)
   - Tree edit distance для похожих структур
   - Группировка результатов
   - Визуализация дубликатов

2. **Добавить индексацию структуры AST**:
   - Индекс для быстрого поиска похожих структур
   - Кэширование нормализованных AST

3. **Интеграция с рефакторингом**:
   - Автоматическое предложение извлечения в функцию/класс
   - Использование `extract_superclass` для устранения дубликатов

## Практический пример: Поиск похожих методов инициализации

### Шаг 1: Найти все методы `__init__`

```python
# Найти все классы
classes = search_ast_nodes(
    node_type="ClassDef",
    file_path="test_data/bhlff"
)

# Для каждого класса найти методы __init__
# (можно использовать list_class_methods)
```

### Шаг 2: Получить AST для сравнения

```python
# Получить AST для двух файлов с похожими классами
ast1 = get_ast("test_data/bhlff/utils/cuda_backend.py")
ast2 = get_ast("test_data/bhlff/utils/cpu_backend.py")

# Извлечь методы __init__ из AST JSON
# Сравнить структуру (нормализовать имена переменных)
```

### Шаг 3: Анализ структуры

Из полученных AST видно, что `CUDABackend.__init__` и `CPUBackend.__init__` имеют похожую структуру:
- Оба проверяют доступность (CUDA/NumPy FFT)
- Оба инициализируют logger
- Оба имеют похожую структуру присваиваний

**Это можно использовать для поиска дубликатов**:
1. Извлечь структуру методов из AST
2. Нормализовать (заменить имена переменных)
3. Сравнить структуру
4. Найти похожие методы

## Заключение

**Текущие возможности**:
- ✅ Получение AST для анализа (`get_ast`)
- ✅ Поиск узлов по типу (`search_ast_nodes`)
- ✅ Семантический поиск похожего кода (`semantic_search`)
- ✅ Хранение AST в БД с хешами (`ast_hash`)
- ✅ Получение информации о сущностях (`get_code_entity_info`)

**Что можно делать сейчас**:
1. **Использовать `semantic_search`** для поиска логически похожего кода
2. **Использовать `get_ast` + `search_ast_nodes`** для ручного анализа структуры
3. **Использовать SQL запросы** для поиска идентичных AST через `ast_hash`:
   ```sql
   SELECT f1.path, f2.path, at1.ast_hash
   FROM ast_trees at1
   JOIN ast_trees at2 ON at1.ast_hash = at2.ast_hash AND at1.file_id != at2.file_id
   JOIN files f1 ON at1.file_id = f1.id
   JOIN files f2 ON at2.file_id = f2.id
   WHERE f1.project_id = ?
   ```
4. **Использовать `get_code_entity_info`** для детального анализа похожих сущностей

**Что нужно добавить**:
- Команда `find_code_duplicates` для автоматического поиска
- Нормализация AST для сравнения (замена имен переменных)
- Tree edit distance для похожих (не идентичных) структур
- Группировка и визуализация результатов
- Индексация нормализованных AST для быстрого поиска

**AST предоставляет мощную основу для поиска дубликатов**, но требуется дополнительная реализация для автоматизации процесса. **Текущие команды позволяют проводить анализ вручную**, комбинируя `get_ast`, `search_ast_nodes` и `semantic_search`.

