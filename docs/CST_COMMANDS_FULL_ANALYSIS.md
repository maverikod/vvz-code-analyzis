# Полный анализ всех CST команд

**Author**: Vasiliy Zdanovskiy  
**Email**: vasilyvz@gmail.com  
**Date**: 2025-01-12

## Обзор

В проекте существует **10 CST команд**, которые можно разделить на две группы:

### Группа 1: Tree-based команды (In-Memory Tree)
Работают с деревом в памяти на сервере:
1. `cst_load_file` - загрузка файла в дерево
2. `cst_modify_tree` - модификация дерева
3. `cst_save_tree` - сохранение дерева в файл
4. `cst_reload_tree` - перезагрузка дерева из файла
5. `cst_find_node` - поиск узлов в дереве
6. `cst_get_node_info` - получение информации о узле
7. `cst_get_node_by_range` - получение узла по диапазону строк

### Группа 2: File-based команды (Traditional)
Работают напрямую с файлами:
8. `compose_cst_module` - применение CST дерева к файлу
9. `list_cst_blocks` - список логических блоков
10. `query_cst` - запрос узлов через CSTQuery

---

## Детальный анализ команд

### 1. cst_load_file

**Назначение**: Загружает Python файл в CST дерево и сохраняет его в памяти на сервере.

**Параметры**:
- `project_id` (required) - идентификатор проекта
- `file_path` (required) - путь к файлу относительно корня проекта
- `root_dir` (optional) - корневая директория сервера
- `node_types` (optional) - фильтр по типам узлов
- `max_depth` (optional) - максимальная глубина узлов
- `include_children` (optional, default=True) - включать информацию о детях

**Возвращает**:
- `tree_id` - идентификатор дерева для использования в других командах
- `file_path` - абсолютный путь к файлу
- `nodes` - список метаданных узлов
- `total_nodes` - общее количество узлов

**Логика**:
1. Разрешает абсолютный путь через `project_id` и базу данных
2. Валидирует файл (.py)
3. Парсит файл через LibCST
4. Строит индекс узлов и метаданные
5. Сохраняет дерево в памяти с `tree_id`
6. Возвращает `tree_id` и метаданные узлов

**Проблемы**: ❌ Нет

**Статус**: ✅ Работает корректно

---

### 2. cst_modify_tree

**Назначение**: Модифицирует CST дерево атомарными операциями.

**Параметры**:
- `tree_id` (required) - идентификатор дерева
- `operations` (required) - список операций
  - `action`: "replace" | "replace_range" | "insert" | "delete"
  - `node_id` - для replace/delete
  - `code` / `code_lines` - новый код для replace/insert
  - `position`: "before" | "after" - для insert
  - `parent_node_id` / `target_node_id` - для insert
  - `start_node_id` / `end_node_id` - для replace_range
- `preview` (optional, default=False) - режим предпросмотра

**Возвращает**:
- `tree_id` - новый идентификатор дерева (или старый в preview)
- `operations_applied` - количество примененных операций
- `diff` - diff изменений (в preview режиме)
- `validation` - результат валидации (в preview режиме)

**Логика**:
1. Валидирует `tree_id` существует
2. Конвертирует операции в `TreeOperation` объекты
3. Валидирует все операции перед применением
4. Применяет операции атомарно
5. Валидирует результирующий модуль (compile)
6. Обновляет дерево в памяти
7. Возвращает новый `tree_id` (или старый в preview)

**Проблемы**: ❌ Нет

**Статус**: ✅ Работает корректно

---

### 3. cst_save_tree

**Назначение**: Сохраняет CST дерево в файл с атомарными операциями.

**Параметры**:
- `tree_id` (required) - идентификатор дерева
- `project_id` (required) - идентификатор проекта
- `file_path` (required) - путь к файлу относительно корня проекта
- `root_dir` (optional) - корневая директория сервера
- `dataset_id` (optional) - идентификатор датасета
- `validate` (optional, default=True) - валидировать перед сохранением
- `backup` (optional, default=True) - создавать backup
- `commit_message` (optional) - сообщение для git commit
- `auto_reload` (optional, default=True) - автоматически перезагрузить дерево после сохранения

**Возвращает**:
- `success` - успех операции
- `file_path` - путь к сохраненному файлу
- `file_id` - ID файла в базе данных
- `backup_uuid` - UUID созданного backup
- `update_result` - результат обновления базы данных
- `tree_reloaded` - был ли перезагружен tree_id

**Логика**:
1. Разрешает абсолютный путь через `project_id`
2. Создает backup (если файл существует и `backup=True`)
3. Генерирует код из дерева
4. Записывает во временный файл
5. Валидирует временный файл (compile)
6. Начинает транзакцию БД
7. Атомарно заменяет файл через `os.replace()`
8. Обновляет базу данных
9. Коммитит транзакцию
10. Создает git commit (если `commit_message` указан)
11. Перезагружает дерево из файла (если `auto_reload=True`)
12. При ошибке: откатывает транзакцию и восстанавливает backup

**Проблемы**: ❌ Нет

**Статус**: ✅ Работает корректно

---

### 4. cst_reload_tree

**Назначение**: Перезагружает CST дерево из файла, обновляя существующее дерево в памяти.

**Параметры**:
- `tree_id` (required) - идентификатор дерева для перезагрузки
- `node_types` (optional) - фильтр по типам узлов
- `max_depth` (optional) - максимальная глубина узлов
- `include_children` (optional, default=True) - включать информацию о детях

**Возвращает**:
- `tree_id` - тот же идентификатор (не меняется)
- `file_path` - путь к файлу
- `nodes` - обновленные метаданные узлов
- `total_nodes` - общее количество узлов
- `reloaded` - всегда True

**Логика**:
1. Валидирует `tree_id` существует
2. Читает файл с диска (используя `file_path` из дерева)
3. Парсит через LibCST
4. Обновляет дерево на месте (не создает новое)
5. Перестраивает индекс узлов и метаданные
6. Возвращает обновленные метаданные

**Проблемы**: ❌ Нет

**Статус**: ✅ Работает корректно

---

### 5. cst_find_node

**Назначение**: Находит узлы в CST дереве используя простой или XPath-подобный поиск.

**Параметры**:
- `tree_id` (required) - идентификатор дерева
- `search_type` (optional, default="xpath") - тип поиска: "simple" | "xpath"
- `query` (optional) - CSTQuery селектор (для xpath)
- `node_type` (optional) - фильтр по типу узла (для simple)
- `name` (optional) - фильтр по имени (для simple)
- `qualname` (optional) - фильтр по квалифицированному имени (для simple)
- `start_line` (optional) - фильтр по начальной строке (для simple)
- `end_line` (optional) - фильтр по конечной строке (для simple)

**Возвращает**:
- `tree_id` - идентификатор дерева
- `search_type` - использованный тип поиска
- `matches` - список метаданных найденных узлов
- `total_matches` - общее количество совпадений

**Логика**:
1. Валидирует `tree_id` существует
2. Валидирует параметры поиска в зависимости от `search_type`
3. Выполняет поиск на дереве в памяти
4. Возвращает метаданные найденных узлов

**Проблемы**: ❌ Нет

**Статус**: ✅ Работает корректно

---

### 6. cst_get_node_info

**Назначение**: Получает детальную информацию о узле в CST дереве.

**Параметры**:
- `tree_id` (required) - идентификатор дерева
- `node_id` (required) - идентификатор узла
- `include_code` (optional, default=False) - включать код узла
- `include_children` (optional, default=False) - включать информацию о детях
- `include_parent` (optional, default=False) - включать информацию о родителе
- `max_children` (optional) - максимальное количество детей для возврата

**Возвращает**:
- `tree_id` - идентификатор дерева
- `node` - метаданные узла
- `children` - список детей (если `include_children=True`)
- `children_count` - количество детей (если `include_children=True`)
- `parent` - метаданные родителя (если `include_parent=True`)

**Логика**:
1. Валидирует `tree_id` существует
2. Валидирует `node_id` существует в дереве
3. Получает метаданные узла
4. Опционально получает детей (с лимитом)
5. Опционально получает родителя
6. Возвращает объединенную информацию

**Проблемы**: ❌ Нет

**Статус**: ✅ Работает корректно

---

### 7. cst_get_node_by_range

**Назначение**: Получает идентификатор узла для конкретного диапазона строк.

**Параметры**:
- `tree_id` (required) - идентификатор дерева
- `start_line` (required) - начальная строка (1-based)
- `end_line` (required) - конечная строка (1-based)
- `prefer_exact` (optional, default=True) - предпочитать точное совпадение
- `all_intersecting` (optional, default=False) - возвращать все пересекающиеся узлы

**Возвращает**:
- `tree_id` - идентификатор дерева
- `start_line` / `end_line` - диапазон строк
- `node` - метаданные узла (если `all_intersecting=False`)
- `nodes` - список метаданных узлов (если `all_intersecting=True`)
- `exact_match` - точное совпадение (если `all_intersecting=False`)
- `total_nodes` - количество узлов (если `all_intersecting=True`)

**Логика**:
1. Валидирует `tree_id` существует
2. Валидирует диапазон строк (start_line <= end_line)
3. Находит узел(ы), покрывающие диапазон
4. Возвращает метаданные узла(ов)

**Проблемы**: ❌ Нет

**Статус**: ✅ Работает корректно

---

### 8. compose_cst_module

**Назначение**: Применяет CST дерево к файлу с атомарными операциями.

**Параметры**:
- `project_id` (required) - идентификатор проекта
- `file_path` (required) - путь к файлу относительно корня проекта
- `tree_id` (required) - идентификатор CST дерева
- `commit_message` (optional) - сообщение для git commit

**Возвращает**:
- `success` - успех операции
- `file_path` - путь к файлу
- `file_id` - ID файла в базе данных
- `backup_uuid` - UUID созданного backup
- `update_result` - результат обновления базы данных
- `git_commit` - информация о git commit

**Логика**:
1. Разрешает абсолютный путь через `project_id`
2. Получает CST дерево через `get_tree(tree_id)`
3. Генерирует весь код из дерева: `source_code = tree.module.code`
4. **Заменяет весь файл** этим кодом
5. Валидирует, сохраняет в БД, делает git commit

**Проблемы**:

#### ❌ Проблема 1: Неправильный параметр
- **Текущее**: `tree_id` - идентификатор готового CST дерева
- **Требуется**: `node_id` - идентификатор узла для вставки (опциональный)

#### ❌ Проблема 2: Отсутствует логика подсоединения к узлу
- **Текущее**: Заменяет весь файл кодом из `tree_id`
- **Требуется**: Подсоединяет ветку к указанному `node_id`

#### ❌ Проблема 3: Отсутствует валидация node_id
- **Текущее**: Нет проверки на пустой `node_id` при существующем файле
- **Требуется**: 
  - Если `node_id` пустой и файл существует → ошибка
  - Если `node_id` пустой и файл новый → допустимо

#### ❌ Проблема 4: Отсутствует источник кода для вставки
- **Текущее**: Код берется из `tree.module.code` (весь файл)
- **Требуется**: Нужен источник кода для вставки в узел

**Статус**: ⚠️ Требует исправления

**Рекомендации**:
1. Добавить параметр `node_id` (optional)
2. Добавить валидацию: если `node_id` пустой и файл существует → ошибка
3. Реализовать логику вставки кода в узел (использовать логику из `cst_modify_tree`)
4. Уточнить источник кода для вставки (из `tree_id` или отдельный параметр `code`)

---

### 9. list_cst_blocks

**Назначение**: Списывает логические блоки (функции/классы/методы) с стабильными ID.

**Параметры**:
- `file_path` (required) - путь к файлу
- `project_id` (optional) - идентификатор проекта
- `root_dir` (optional) - корневая директория

**Возвращает**:
- `file_path` - путь к файлу
- `blocks` - список блоков с:
  - `id` - стабильный идентификатор блока
  - `kind` - тип блока (function, class, method)
  - `qualname` - квалифицированное имя
  - `start_line` / `end_line` - диапазон строк

**Логика**:
1. Разрешает путь через `project_id` или `root_dir`
2. Валидирует файл (.py)
3. Читает файл
4. Парсит через LibCST
5. Извлекает логические блоки (functions, classes, methods)
6. Генерирует стабильные block_id
7. Возвращает список блоков

**Проблемы**: ❌ Нет

**Статус**: ✅ Работает корректно

**Примечание**: Эта команда используется для получения `block_id` для `compose_cst_module`, но может быть заменена на `cst_load_file` + `cst_find_node`.

---

### 10. query_cst

**Назначение**: Находит узлы LibCST используя CSTQuery селекторы.

**Параметры**:
- `file_path` (required) - путь к файлу
- `selector` (required) - CSTQuery селектор
- `project_id` (optional) - идентификатор проекта
- `root_dir` (optional) - корневая директория
- `include_code` (optional, default=False) - включать код узлов
- `max_results` (optional, default=200) - максимальное количество результатов

**Возвращает**:
- `file_path` - путь к файлу
- `selector` - использованный селектор
- `truncated` - были ли результаты обрезаны
- `matches` - список найденных узлов с:
  - `node_id` - идентификатор узла
  - `kind`, `type`, `name`, `qualname` - метаданные
  - `start_line`, `start_col`, `end_line`, `end_col` - позиция
  - `code` - код узла (если `include_code=True`)

**Логика**:
1. Разрешает путь через `project_id` или `root_dir`
2. Валидирует файл (.py)
3. Читает файл
4. Парсит через LibCST
5. Применяет CSTQuery селектор
6. Генерирует node_id для каждого совпадения
7. Ограничивает результаты до `max_results`
8. Возвращает список совпадений

**Проблемы**: ❌ Нет

**Статус**: ✅ Работает корректно

**Примечание**: Эта команда может быть заменена на `cst_load_file` + `cst_find_node` с `search_type="xpath"`.

---

## Сравнительный анализ групп команд

### Tree-based команды (Группа 1)

**Преимущества**:
- ✅ Дерево хранится в памяти на сервере (быстрый доступ)
- ✅ Множественные операции на одном дереве без перезагрузки
- ✅ Атомарность операций
- ✅ Эффективный поиск узлов на сервере
- ✅ Поддержка preview режима

**Недостатки**:
- ⚠️ Требует управления жизненным циклом дерева (load → modify → save)
- ⚠️ Дерево может стать невалидным после внешних изменений файла
- ⚠️ Больше шагов для простых операций

**Workflow**:
```
cst_load_file → cst_find_node → cst_modify_tree → cst_save_tree
```

### File-based команды (Группа 2)

**Преимущества**:
- ✅ Простота использования для одиночных операций
- ✅ Нет управления жизненным циклом дерева
- ✅ Всегда работает с актуальной версией файла

**Недостатки**:
- ⚠️ Каждый раз парсит файл заново
- ⚠️ Нет возможности множественных операций на одном дереве
- ⚠️ Меньше контроля над атомарностью

**Workflow**:
```
list_cst_blocks / query_cst → compose_cst_module
```

---

## Проблемы и несоответствия

### 1. compose_cst_module не соответствует требованиям

**Проблема**: Команда использует `tree_id` вместо `node_id` и не поддерживает вставку в узел.

**Требования**:
- `project_id` - ✅ есть
- `file_path` - ✅ есть
- `node_id` - ❌ нет (есть `tree_id`)
- `commit_message` - ✅ есть

**Решение**: См. анализ в разделе "8. compose_cst_module".

### 2. Дублирование функциональности

**Проблема**: `list_cst_blocks` и `query_cst` дублируют функциональность `cst_load_file` + `cst_find_node`.

**Решение**: 
- Оставить все команды для обратной совместимости
- Рекомендовать использовать tree-based команды для новых проектов

### 3. Разные подходы к работе с файлами

**Проблема**: Tree-based команды требуют `project_id`, а file-based команды могут использовать `root_dir`.

**Решение**: Унифицировать подход - всегда требовать `project_id` для всех команд.

---

## Рекомендации

### 1. Исправить compose_cst_module

Добавить поддержку `node_id`:
- Если `node_id` пустой и файл существует → ошибка
- Если `node_id` пустой и файл новый → создать файл из `tree_id`
- Если `node_id` указан → вставить код из `tree_id` в узел

### 2. Унифицировать параметры

Все команды должны использовать `project_id` вместо `root_dir` для разрешения путей.

### 3. Документировать workflow

Создать документацию с примерами использования обеих групп команд и рекомендациями когда использовать каждую.

### 4. Добавить валидацию

Добавить валидацию параметров во всех командах для раннего обнаружения ошибок.

---

## Выводы

1. **Tree-based команды** (1-7) работают корректно и предоставляют мощный API для работы с CST деревьями.

2. **File-based команды** (8-10) работают корректно, но:
   - `compose_cst_module` требует исправления для поддержки `node_id`
   - `list_cst_blocks` и `query_cst` дублируют функциональность tree-based команд

3. **Основная проблема**: `compose_cst_module` не соответствует требованиям пользователя и требует доработки.

4. **Рекомендация**: Исправить `compose_cst_module` согласно требованиям, сохранив обратную совместимость с существующим API.
